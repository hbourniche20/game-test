<?php


namespace App\Mechanic;


class ServerRaidBossChar extends ServerRaidCharacter
{

    public $phase;

    public function __construct($characterData, $playerIndex){
        // Parent construct
        parent::__construct($characterData, $playerIndex);

        $this->phase = 0;
    }

    public function getAnimPos($kind){
        switch ($kind){
            case "wait":
                if ($this->phase > 0){
                    return "wait_" . $this->phase;
                }
                return "wait";
            case "damage":
                if ($this->phase > 0){
                    return "damage_" . $this->phase;
                }
                return "damage";
            case "attack":
                if ($this->phase > 0){
                    return "attack_" . $this->phase;
                }
                return "attack";
        }
    }

    public function canMortal(){
        return ($this->getCurrentAttr('diamond') >= $this->getMaxAttr('diamond'));
    }

    public function chooseRandomMortal(){
        $mortalList = [
            "boss_mortal_0",
            "boss_mortal_1",
            "boss_mortal_2",
            "boss_mortal_3",
        ];

        $rI = random_int(0, count($mortalList));

        return $mortalList[$rI];
    }

    public function countdownTurn($countdown = 1)
    {
        parent::countdownTurn($countdown); // TODO: Change the autogenerated stub
        // Fill diamond to active Mortal next turn
        $this->gainCurrentAttr('diamond', 1);
    }
    public function gainCurrentAttr($name, $value)
    {
        parent::gainCurrentAttr($name, $value); // TODO: Change the autogenerated stub
        // Diamong max
        if ($this->getCurrentAttr("diamond") >= $this->getMaxAttr("diamond")){
            $this->defaultWait = "setin_2";
        }
    }

    public function onSuccessOneAttack()
    {
        parent::onSuccessOneAttack(); // TODO: Change the autogenerated stub
        // Gain diamond too
        $this->gainCurrentAttr('diamond', 1);
    }

    public function applyMortalDamage($mortal, ServerRaidCharacter $targetChar){
        // reset diamond
        $this->setCurrentAttr('diamond', 0);
        // To store several step of damage for animation
        $damageStepResult = [];
        // Apply damage for each attack
        // Damage formula by attack attempt for more random
        $damage = $this->getCurrentAttr('baseDamage') * 2;
        // Random supplement , more strong by triple attack
        $supp = random_int(0, 100);
        // Store damage apply result
        $damageStepResult[0] = $targetChar->looseHP($damage + $supp);

        return $damageStepResult;
    }
}